?optim
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
#Rcpp::sourceCpp('Business/University/Master\'s/Project/Package/scr/src/acoustic.cpp')
test = scr.sim(5, 150, test.data$traps, density = 5, acoustic = TRUE, lambda_c = 3)
par.start = c("D" = 5, "g0" = 5, "sigma" = 150, "lamda_c" = 3)
par.start
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
?scr.sim
scr.sim(5, 150, test.data$traps, acoustic = TRUE)
scr.sim(5, 150, test.data$traps, acoustic = TRUE, lambda_c = 3)
test = scr.sim(5, 15, test.data$traps, acoustic = TRUE, lambda_c = 3)
head(test)
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
?scr.fit
test = scr.sim(5, 150, test.data$traps, density = 5, acoustic = TRUE, lambda_c = 3)
par.start = c(5, 5, 150, 3)
scr.fit(test, test.data$traps, test.data$mask, start = par.start, acoustic = TRUE)
scr.fit(test, test.data$traps, test.data$mask, start = c(5, .5, 150, 3), acoustic = TRUE)
test
test = scr.sim(3, 15, test.data$traps / 10, density = 2, acoustic = TRUE, lambda_c = 3)
test
test = scr.sim(3, 15, test.data$traps / 10, density = 5, acoustic = TRUE, lambda_c = 3)
test
test.data$traps / 10
test = scr.sim(3, 100, test.data$traps / 10, density = 5, acoustic = TRUE, lambda_c = 3)
test
test.data$traps
test.data$traps / 10
plot(test.data$traps / 10)
test = scr.sim(3, 20, test.data$traps / 10, density = 5, acoustic = TRUE, lambda_c = 3)
test
?scr.fit
scr.fit(test, test.data$traps / 10, test.data$mask / 10, start = c(5, .5, 20, 3), acoustic = TRUE)
scr.sim(5, 15, test.data$traps / 10, acoustic = TRUE, lambda_c = 3)
scr.sim(5, 15, test.data$traps / 10, acoustic = TRUE, lambda_c = 3, distr = "binom")
?scr.sim
library(secr)
library(scr)
## Simulating a data set
## Generating 16 random trap coordinates
#test = cbind(1:99, rep(99:1, each = 99))
#test2 = test[sample(1:nrow(test), (nrow(test) * 16) / 9800), ]
test2 = as.matrix(read.table("Sim-info/traps.txt", header = TRUE))
test2 = test.data$traps / 10
simdata = function(write = TRUE) {
## Reformatting the trap locations so as to create a proper "traps" object
## Then creating the "traps" object
colnames(test2) = c("x", "y")
if(write) {
write.table(test2, "Sim-info/traps.txt", quote = FALSE, row.names = FALSE)
}
## Poisson:
pois.testraps = read.traps(data = data.frame(testID = 1:nrow(test2), test2), detector = "count")
## Binary:
bin.testraps = read.traps(data = data.frame(testID = 1:nrow(test2), test2), detector = "proximity")
## NegBin:
#negbin.testraps = read.traps(data = data.frame(testID = 1:nrow(test2), test2), detector = "count")
## Creating the mask
pois.testmask = make.mask(pois.testraps, type = "trapbuffer", buffer = 10 * 5)
bin.testmask = make.mask(bin.testraps, type = "trapbuffer", buffer = 10 * 5)
#negbin.testmask = make.mask(negbin.testraps, type = "trapbuffer", buffer = 10 * 5)
## Simulating the data
## Saving the captures so that they can be converted and comparable
##    - NOTE THAT THEY'RE BEING GENERATED NEGBIN
rawCounts = scr.sim(5, 15, test2, density = 50, distr = "nbinom", size = 0.5)
##  - Poisson:
pois.caps = toCapthist(rawCounts)
##  - Binary:
bin.caps = toCapthist(ifelse(rawCounts > 0, 1, 0))
##  - NegBin:
#negbin.caps = toCapthist(scr.sim(5, 15, test2, distr = "nbinom"))
## Creating a "capthist" object
pois.caps = make.capthist(pois.caps, pois.testraps, fmt = "trapID")
bin.caps = make.capthist(bin.caps, bin.testraps, fmt = "trapID")
#negbin.caps = make.capthist(negbin.caps, negbin.testraps, fmt = "trapID")
## Returning the traps, mask, and captures (as a capthist object)
list(poisson = list(traps = pois.testraps,
mask = pois.testmask,
captures = pois.caps),
binary = list(traps = bin.testraps,
mask = bin.testmask,
captures = bin.caps))#,
# negbin = list(traps = negbin.testraps,
#               mask = negbin.testmask,
#               captures = negbin.caps))
}
simdata(write = FALSE)
## Function to extract and save estimates
save.est = function(fit, filename) {
## Extracting estimates
beta = exp(coef(fit)$beta)
CI = exp(unlist(c(coef(fit)[1, 3:4],
coef(fit)[2, 3:4],
coef(fit)[3, 3:4])))
SE = coef(fit)[, 2]
## Creating filename
fn = paste0("Estimates/", filename, "/", filename, "-", c("beta", "CI", "SE"), ".txt")
## Appending estimates to file
write(beta, fn[1], append = TRUE, ncol = 3)
write(CI, fn[2], append = TRUE, ncol = 6)
write(SE, fn[3], append = TRUE, ncol = 3)
}
scr.est = function(n, write = FALSE) {
## Getting the timing
write.table(paste("Start:", Sys.time()), "Sim-info/timing.txt", quote = FALSE, col.names = FALSE)
## Creating the variable estimates
#beta = CI = SE = NULL
for(i in 1:n) {
## Simulating a new data set
sim = simdata(write = FALSE)
#write.table(caps, "Sim-info/caps.txt", quote = FALSE)
## Getting a fit for the capture data
pois.fit = secr.fit(sim$poisson$captures, mask = sim$poisson$mask, detectfn = "HHN", trace = FALSE)
bin.fit = secr.fit(sim$binary$captures, mask = sim$binary$mask, detectfn = "HHN", trace = FALSE)
#negbin.fit = secr.fit(sim$negbin$captures, mask = sim$negbin$mask, detectfn = "HHN", trace = FALSE, binomN = -2)
## Storing and updating the estimates
#beta = rbind(beta, exp(coef(fit)$beta))
#CI = rbind(CI, exp(unlist(c(coef(fit)[1, 3:4],
#                            coef(fit)[2, 3:4],
#                            coef(fit)[3, 3:4]))))
#SE = rbind(SE, coef(fit)[, 2])
## Writing the estimates to a txt file
#write(beta[i, ], "Estimates/beta.txt", append = TRUE, ncol = 3)
#write(CI[i, ], "Estimates/CI.txt", append = TRUE, ncol = 6)
#write(SE[i, ], "Estimates/SE.txt", append = TRUE, ncol = 3)
## Saving estimates
save.est(pois.fit, "Poisson")
save.est(bin.fit, "Binary")
#save.est(negbin.fit, "NegBin")
}
## Getting the timing
write.table(paste("End:", Sys.time()), "Sim-info/timing.txt", quote = FALSE, col.names = FALSE, append = TRUE)
}
scr.est(100)
scr.est = function(n, write = FALSE) {
## Getting the timing
#write.table(paste("Start:", Sys.time()), "Sim-info/timing.txt", quote = FALSE, col.names = FALSE)
## Creating the variable estimates
#beta = CI = SE = NULL
for(i in 1:n) {
## Simulating a new data set
sim = simdata(write = FALSE)
#write.table(caps, "Sim-info/caps.txt", quote = FALSE)
## Getting a fit for the capture data
pois.fit = secr.fit(sim$poisson$captures, mask = sim$poisson$mask, detectfn = "HHN", trace = FALSE)
bin.fit = secr.fit(sim$binary$captures, mask = sim$binary$mask, detectfn = "HHN", trace = FALSE)
#negbin.fit = secr.fit(sim$negbin$captures, mask = sim$negbin$mask, detectfn = "HHN", trace = FALSE, binomN = -2)
## Storing and updating the estimates
#beta = rbind(beta, exp(coef(fit)$beta))
#CI = rbind(CI, exp(unlist(c(coef(fit)[1, 3:4],
#                            coef(fit)[2, 3:4],
#                            coef(fit)[3, 3:4]))))
#SE = rbind(SE, coef(fit)[, 2])
## Writing the estimates to a txt file
#write(beta[i, ], "Estimates/beta.txt", append = TRUE, ncol = 3)
#write(CI[i, ], "Estimates/CI.txt", append = TRUE, ncol = 6)
#write(SE[i, ], "Estimates/SE.txt", append = TRUE, ncol = 3)
## Saving estimates
save.est(pois.fit, "Poisson")
save.est(bin.fit, "Binary")
#save.est(negbin.fit, "NegBin")
}
## Getting the timing
write.table(paste("End:", Sys.time()), "Sim-info/timing.txt", quote = FALSE, col.names = FALSE, append = TRUE)
}
scr.est(100)
scr.fit(test, test.data$traps, test.data$mask, start = par.start, acoustic = TRUE)
par.start = c(5, .5, 150, 3)
scr.fit(test, test.data$traps, test.data$mask, start = par.start, acoustic = TRUE)
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10)
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3)
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE)
debug(scr.sim)
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE)
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE, distr = "binom")
c
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE, distr = "binom")
F
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE, distr = "binom")
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE, distr = "binom")
lambda_0 * exp(-d^2 / (2 * sigma^2))
lambda_0 * exp(-d^2 / (2 * sigma^2))
lambda_0
exp(0)
t = function(lambda_0, sigma, traplocs,
density = 50,
distr = "pois",
limits = list(xlim = NULL, ylim = NULL),
counts = "counts",
draw = FALSE,
acoustic = FALSE,
lambda_c = NULL,
...) {
## Setting up the total survey area
##  - Survey area (vs. trap area) is based on extreme trap co-ordinates
##    - Ranges are taken from each x and y column
##    - Co-ordinates are extended by (5 * sigma); stored as survey area box
##  - Then some error handling (i.e. only x or only y coordinates missing)
if(is.null(limits$xlim) & is.null(limits$ylim)) {
limits = list(xlim = range(traplocs[, 1], na.rm = TRUE),
ylim = range(traplocs[, 2], na.rm = TRUE))
limits = lapply(limits, "+", c(-1, 1) * (5 * sigma))
} else if(is.null(limits$xlim) & !is.null(limits$ylim)) {
stop("X co-ordinates missing")
} else if(!is.null(limits$xlim) & is.null(limits$ylim)) {
stop("Y coordinates missing")
}
## Generating random points on the area
##  - Area calculated from xlim and ylim
##  - Total number of animals N ~ Pois(DA)
##    - Density (D) is given per hectare, so divide by 10,000 to get per metre
area = (limits$xlim[2] - limits$xlim[1]) * (limits$ylim[2] - limits$ylim[1])
n = rpois(1, (density / 10000) * area)
coords = pointgen(n, xlim = limits$xlim, ylim = limits$ylim)
## Plotting the traps and activity centres, provided draw = TRUE
if(draw) {
## Setting up the survey area
plot.new()
plot.window(xlim = limits$xlim,
ylim = limits$ylim,
xaxs = "i", yaxs = "i")
box()
## Setting up the traps
points(traplocs, pch = 3, col = "red")
## Plotting the activity centres
points(coords, ...)
}
## Acoustic captures
## - Each animal has a matrix of captures - 1 per call
##    - Obviously, if none of the "traps" captured a call, it isn't recorded
## - Have some average # of calls (lambda_c)
##    - Randomly generate (lambda_c) capture histories for each call
if(acoustic && is.null(lambda_c)) {
stop("Acoustic calls need a mean number of calls (lambda_c)")
}
## Setting up the random count generation - depending on the distribution
if(distr == "pois") {
rDistr = paste0("r", distr, "(length(d), lambda_0 * exp(-d^2 / (2 * sigma^2)))")
} else if(distr == "bernoulli" | distr == "binom") {
rDistr = paste0("r", "binom", "(length(d), 1, lambda_0 * exp(-d^2 / (2 * sigma^2)))")
} else if(distr == "negbin" | distr == "nbinom") {
ifelse(!is.null(list(...)$size), size <- list(...)$size, size <- 2)
rDistr = paste0("r", "nbinom", "(length(d), mu = lambda_0 * exp(-d^2 / (2 * sigma^2)), size = size)")
}
## Calculating the distances between each activity centre and every trap, for efficiency.
distances = eucdist_nll(coords, traplocs)
## Filling the omega matrix row-by-row
##  - Counts are randomly generated based on the specified distribution
##  - A row will only be added if its sum > 0; i.e. if at least 1 of the traps had a detection.
##  - The simulated counts are removed at the end of each loop, just to keep things tidy.
##
## Acoustic and regular SCR are differentiated here
## - If it's acoustic, then simCounts is repeated rpois(1, lambda_c) times and bound
##    - Note that if rpois(1, lambda_c) == 0, then you need to generate it again
omega = id = NULL
if(acoustic) {
idIterator = 1
for(i in 1:nrow(coords)) {
d = distances[i, ]
## Generating a random number of calls
nCalls = rpois(1, lambda_c)
while(nCalls == 0) {
nCalls = rpois(1, lambda_c)
}
## Generating [nCalls] detection vectors for a given animal's calls
#parseEval(rDistr)))
## Dropping out the 0 counts
## Also storing animal labels in a separate vector
## - Label only added if counts > 1
simCounts = simCounts[as.logical(rowSums(simCounts)), ]
if(length(simCounts) / nrow(traplocs) > 0) {
## Adding label
id = c(id, rep(idIterator, length(simCounts) / nrow(traplocs)))
## Keeping track of labels
idIterator = idIterator + 1
}
## Binding the matrices to the "grand matrix"
omega = rbind(omega,
simCounts)
## Cleaning up
rm(simCounts)
}
#omega = cbind(omega, id)
} else {
for(i in 1:nrow(coords)) {
d = distances[i, ]
simCounts = eval(parse(text = rDistr))
## Dropping out the 0 counts
if(sum(simCounts) != 0) {
omega = rbind(omega,
simCounts)
}
## Cleaning up
rm(simCounts)
}
}
## Removing the row names given as a result of rbind()
rownames(omega) = NULL
## Converting the count data to binary, if the count type = "binary"
## Acoustic counts are also returned as binary
if(distr == "binom") {
omega = ifelse(omega > 0, 1, 0)
} else if(acoustic) {
omega = ifelse(omega > 0, 1, 0)
omega = cbind(omega, id)
}
omega
}
deb ug(t)
debug(t)
t(5, 15, test.data$traps / 10, acoustic = TRUE, lambda_c = 3, distr = "rbinom")
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE, distr = "binom")
t(replicate(nCalls, eval(parse(text = rDistr))))
omega
omega
scr.sim(5, 15, acoustic = TRUE, traplocs = test.data$traps / 10, lambda_c = 3, draw = TRUE, distr = "binom")
omega
simCounts
simCounts
simCounts
simCounts
omega
simCounts
simCounts
warnings()
simCounts
id
simCounts
omega
simCounts
simCounts
simCounts
traceback()
rbinom(length(d), 1, lambda_0 * exp(-d^2/(2 * sigma^2)))
lambda_0
lambda_0 * exp(-d^2/(2 * sigma^2))
rbinom(1, 1, 2)
sim.scr(5, 15, test.data$traps / 10, distr = "binom")
scr.sim(5, 15, test.data$traps / 10, distr = "binom")
sim.scr(.99, 15, test.data$traps / 10, distr = "binom")
scr.sim(.99, 15, test.data$traps / 10, distr = "binom")
scr.sim(.99, 15, test.data$traps / 10, distr = "binom", acoustic = TRUE, lambda_c = 3)
library(scr)
scr.sim(.99, 15, test.data$traps / 10, distr = "binom", acoustic = TRUE, lambda_c = 3)
scr.sim(.99, 15, test.data$traps / 10, distr = "negbin", acoustic = TRUE, lambda_c = 3)
scr.sim(.99, 15, test.data$traps / 10, distr = "negbin", acoustic = TRUE, lambda_c = 3)
scr.sim(.75, 15, test.data$traps / 10, acoustic = TRUE, lambda_c = 3)
test = scr.sim(.75, 15, test.data$traps / 10, acoustic = TRUE, lambda_c = 3)
par.start = c(5, .75, 15, 3)
?scr.sim
par.start = c(50, .75, 15, 3)
test = scr.sim(.75, 15, test.data$traps / 10, acoustic = TRUE, lambda_c = 3)
par.start = c(50, .75, 15, 3)
scr.fit(test, test.data$traps / 10, test.data$mask / 10, start = par.start, acoustic = TRUE)
?par
