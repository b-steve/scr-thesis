#=======================#
#  Parameter specified  #
#=======================#
else {
# Error handling: storing all the possible races in lower case
cleanedRaces = tolower(unique(gsub(".?(Male|Female|Surname).?", "", names(names))))
allCombos = tolower(names(names))
# Generating a name based on the details given (if relevant)
# Also note that there is no 'RNGs" vector, and we need to turn the race and sex into numbers
if(is.null(details$race)) {
raceAsNum = rng(max = 8)
race = cleanedRaces[raceAsNum]
} else {
race = tolower(details$race)
raceAsNum = grep(race, cleanedRaces)
}
# Getting a random sex if none is provided, or else, converting it into a number
if(is.null(details$sex)) {
sexAsNum = rng()
sex = ifelse(sexAsNum == 1, "Male", "Female")
} else {
sex = details$sex
sexAsNum = ifelse(tolower(strsplit(sex, "")[[1]][1]) == "m", 1, 2)
}
# Then getting the name
# Dragonborn, Gnome, Goblin, and Orc only have 1 name
if(raceAsNum > 4) {
# Gnomes and Orcs have genered names; finding the Male/Female column
if(raceAsNum < 7) {
col = grep(race, allCombos)[sexAsNum]
}
# Dragonborns and Goblins don't have gendered names
else {
col = grep(race, allCombos)
}
# Then randomly retrieving a name from that column, from the full list of names
name = names[rng(max = length(names[, col])), col]
# Error handling: if the name is literally "NA", then get another one
while(is.na(name)) {
name = names[rng(max = length(names[, col])), col]
}
} else {
# Dwarves, Elves, Humans and Halflings have first name and surname
# Finding Male/Female column
# Then randomly retrieving a name from that column
col = grep(race, allCombos)[sexAsNum]
first = names[rng(max = length(names[, col])), col]
# Surname
snamecol = grep(paste0(race, ".surname"), allCombos)
surname = names[rng(max = length(names[, snamecol])), snamecol]
# Error handling: if the name is literally "NA", then get another one
while(is.na(first) | is.na(surname)) {
if(is.na(first)) {
first = names[rng(max = length(names[, col])), col]
}
if(is.na(surname)) {
surname = names[rng(max = length(names[, snamecol])), snamecol]
}
}
# Putting the name together
name = paste(first, surname)
}
# Making sure the race and sex are formatted nicely
race = paste0(toupper(substr(race, 1, 1)), substring(race, 2))
sex = paste0(toupper(substr(sex, 1, 1)), tolower(substring(sex, 2)))
# Printing out the name, along with the details given
setNames(as.data.frame(rbind("Race:" = race,
"Name:" = name,
"Sex:" = sex),
stringsAsFactors = FALSE),
nm = "")
}
}
race = c("Dwarf", "Human")
#===========================================================================#
#===========================================================================#
#===========================================================================#
#===========================================================================#
#=========================#
#  Tavern name generator  #
#=========================#
tavern = function() {
# Reading in the list of names
wordList = read.xlsx("Behind the screen.xlsx", sheetName = "Tavern names")
# Randomly generating 2 numbers to be used
# Also just grabbing out the second noun, because the second thing is _always_ a noun
first = rng(min = 0, max = nrow(wordList))
nn_or_an = rng()
noun2 = wordList[rng(min = 0, max = nrow(wordList)), 2]
# Putting it all together
# Pastes "The", then gets a random word from either column of the list and pastes it with "and" and the second noun
switch(nn_or_an,
paste("The", wordList[first, 1], noun2),
paste("The", wordList[first, 2], "and", noun2))
}
#===========================================================================#
#===========================================================================#
#===========================================================================#
#===========================================================================#
#=========================#
#       NPC generator     #
npc = function(n = 1, stats = FALSE, ...) {
# Generating a name, race, and sex 'n' times and packaging it in a dataframe
npc.df = t(nameGen(...))
if(n > 1) {
for(i in 2:n) {
npc.df = rbind(npc.df, t(nameGen(...)))
}
# Checking for doubled up names; will generate a new one if there is
while(anyDuplicated(npc.df[, 2])) {
npc.df[anyDuplicated(npc.df[, 2]), ] = t(nameGen(...))
}
}
# Generating an age and alignment and sticking it on
npc.df = cbind(npc.df, ageGen(npc.df[, 1]), align(n))
# Labelling the columns
npc.colnames = c("Race", "Name", "Sex", "Age", "Alignment")
# Generating some random stats, if 'stats' = TRUE (Default = FALSE)
if(stats) {
# Getting the relevant columns: Str:Cha (AC and HP RNG'd)
statNames = c("Str", "Dex", "Con", "Int", "Wis", "Cha")
statsCols = grep(paste(statNames, collapse = "|"), names(workers))
# Randomly selecting 'n' rows
# Then looping through the block of stats and stripping out the modifier (so we can add our own)
rows = rng(n, 1, ncol(workers))
statsNoMods = apply(workers[rows, statsCols], 2, function(x) as.numeric(gsub(" \\([+-]?[0-9]\\)", "", x)))
# Creating our own modifier to stick on
mods = c(-5, rep(-4:5, each = 2))[statsNoMods]
mods[mods > 0] = paste0("+", mods[mods > 0])
# Randomly generating AC and HP
AC = rng(n, 10, 18)
HP = rng(n, 10, 20)
# Sticking our stats onto the main dataframe, and updating the column names
npc.df = cbind(npc.df, AC, matrix(paste0(statsNoMods, " (", mods, ")"),
ncol = 6,
nrow = n),
HP)
npc.colnames = c(npc.colnames, "AC", statNames, "HP")
}
# Packaging and printing
setNames(data.frame(npc.df, stringsAsFactors = FALSE), nm = npc.colnames)
}
npc(stats = TRUE, race = "human")
npc(stats = TRUE)
npc()
#====================================#
#             Preamble               #
#====================================#
library(xlsx)
library(httr)
# Reading in the spreadsheets
names = read.xlsx("Behind the screen.xlsx", "Names",
stringsAsFactors = FALSE)
workers = read.xlsx("Behind the screen.xlsx", "Workers",
stringsAsFactors = FALSE)
#=========================#
#    Helper functions     #
#=========================#
# Random number generator
rng = function(n = 1, min = 1, max = 2) {
round(runif(n, min, max))
}
# Getting ability modifiers
getMod = function(score) {
c(-5, rep(-4:5, each = 2))[score]
}
# Alignment generator
align = function(n = 1) {
# Setting up the combos
LNC = c("L", "N", "C")
GNE = c("G", "N", "E")
# Picking one from each
first = sample(LNC, n, replace = TRUE)
second = sample(GNE, n, replace = TRUE)
# Sticking them together and returning
alignment = paste0(first, second)
alignment[which(alignment == "NN")] = "TN"
alignment
}
# Age generator
ageGen = function(race) {
# Creating somewhere to store the age(s)
age = numeric()
# Looping through the 'race' vector
for(elt in race) {
if(elt == "Dwarf") {
agerange = c(10, 350)
} else if(elt == "Elf") {
agerange = c(20, 750)
} else if(elt == "Human") {
agerange = c(10, 80)
} else if(elt == "Halfling") {
agerange = c(15, 165)
} else if(elt == "Dragonborn") {
agerange = c(15, 165)
} else if(elt == "Gnome") {
agerange = c(15, 165)
} else if(elt == "Orc") {
agerange = c(15, 165)
} else if(elt == "Goblin") {
agerange = c(3, 40)
}
# Storing the age(s) in the 'age' vector
age = c(age, rng(min = agerange[1], max = agerange[2]))
}
# Returning the age vector
setNames(age, nm = race)
}
# Name, Race and Sex generator
nameGen = function(...) {
# Unpacking the possible details given
details = list(...)
#=======================#
# Random mode (default) #
#=======================#
if(length(details) == 0) {
# RNG for race (determines number of names); note that vector 'rng' is used again later
# Takes the names of the columns (i.e. the races) and strips out anything not related to race;
#   then only takes one instance of each
RNGs = c(Race = rng(max = 8),
Sex = rng())
race = unique(gsub(".?(Male|Female|Surname).?", "", names(names)))[RNGs[["Race"]]]
# Dragonborn, Gnome, Goblin, and Orc only have 1 name
if(RNGs[["Race"]] > 4) {
# Gnomes and Orcs have genered names; finding the Male/Female column
if(RNGs[["Race"]] < 7) {
col = grep(race, names(names))[RNGs["Sex"]]
}
# Dragonborns and Goblins don't have gendered names
else {
col = grep(race, names(names))
}
# Then randomly retrieving a name from that column, from the full list of names
name = names[rng(max = length(names[, col])), col]
# Error handling: if the name is literally "NA", then get another one
while(is.na(name)) {
name = names[rng(max = length(names[, col])), col]
}
} else {
# Dwarves, Elves, Humans and Halflings have first name and surname
# Finding Male/Female column
# Then randomly retrieving a name from that column
col = grep(race, names(names))[RNGs["Sex"]]
first = names[rng(max = length(names[, col])), col]
# Surname
snamecol = grep(paste0(race, ".Surname"), names(names))
surname = names[rng(max = length(names[, snamecol])), col]
# Error handling: if the name is literally "NA", then get another one
while(is.na(first) | is.na(surname)) {
if(is.na(first)) {
first = names[rng(max = length(names[, col])), col]
}
if(is.na(surname)) {
surname = names[rng(max = length(names[, snamecol])), col]
}
}
# Putting the name together
name = paste(first, surname)
}
# Final output
sex = ifelse(RNGs["Sex"] == 1, "Male", "Female")
setNames(as.data.frame(rbind("Race:" = race,
"Name:" = name,
"Sex:" = sex),
stringsAsFactors = FALSE),
nm = "")
}
#===============================================================#
#===============================================================#
#===============================================================#
#===============================================================#
#=======================#
#  Parameter specified  #
#=======================#
else {
# Error handling: storing all the possible races in lower case
cleanedRaces = tolower(unique(gsub(".?(Male|Female|Surname).?", "", names(names))))
allCombos = tolower(names(names))
# Generating a name based on the details given (if relevant)
# Also note that there is no 'RNGs" vector, and we need to turn the race and sex into numbers
if(is.null(details$race)) {
raceAsNum = rng(max = 8)
race = cleanedRaces[raceAsNum]
} else {
race = tolower(details$race)
raceAsNum = grep(race, cleanedRaces)
}
# Getting a random sex if none is provided, or else, converting it into a number
if(is.null(details$sex)) {
sexAsNum = rng()
sex = ifelse(sexAsNum == 1, "Male", "Female")
} else {
sex = details$sex
sexAsNum = ifelse(tolower(strsplit(sex, "")[[1]][1]) == "m", 1, 2)
}
# Then getting the name
# Dragonborn, Gnome, Goblin, and Orc only have 1 name
if(raceAsNum > 4) {
# Gnomes and Orcs have genered names; finding the Male/Female column
if(raceAsNum < 7) {
col = grep(race, allCombos)[sexAsNum]
}
# Dragonborns and Goblins don't have gendered names
else {
col = grep(race, allCombos)
}
# Then randomly retrieving a name from that column, from the full list of names
name = names[rng(max = length(names[, col])), col]
# Error handling: if the name is literally "NA", then get another one
while(is.na(name)) {
name = names[rng(max = length(names[, col])), col]
}
} else {
# Dwarves, Elves, Humans and Halflings have first name and surname
# Finding Male/Female column
# Then randomly retrieving a name from that column
col = grep(race, allCombos)[sexAsNum]
first = names[rng(max = length(names[, col])), col]
# Surname
snamecol = grep(paste0(race, ".surname"), allCombos)
surname = names[rng(max = length(names[, snamecol])), snamecol]
# Error handling: if the name is literally "NA", then get another one
while(is.na(first) | is.na(surname)) {
if(is.na(first)) {
first = names[rng(max = length(names[, col])), col]
}
if(is.na(surname)) {
surname = names[rng(max = length(names[, snamecol])), snamecol]
}
}
# Putting the name together
name = paste(first, surname)
}
# Making sure the race and sex are formatted nicely
race = paste0(toupper(substr(race, 1, 1)), substring(race, 2))
sex = paste0(toupper(substr(sex, 1, 1)), tolower(substring(sex, 2)))
# Printing out the name, along with the details given
setNames(as.data.frame(rbind("Race:" = race,
"Name:" = name,
"Sex:" = sex),
stringsAsFactors = FALSE),
nm = "")
}
}
race = c("Dwarf", "Human")
#===========================================================================#
#===========================================================================#
#===========================================================================#
#===========================================================================#
#=========================#
#  Tavern name generator  #
#=========================#
tavern = function() {
# Reading in the list of names
wordList = read.xlsx("Behind the screen.xlsx", sheetName = "Tavern names")
# Randomly generating 2 numbers to be used
# Also just grabbing out the second noun, because the second thing is _always_ a noun
first = rng(min = 0, max = nrow(wordList))
nn_or_an = rng()
noun2 = wordList[rng(min = 0, max = nrow(wordList)), 2]
# Putting it all together
# Pastes "The", then gets a random word from either column of the list and pastes it with "and" and the second noun
switch(nn_or_an,
paste("The", wordList[first, 1], noun2),
paste("The", wordList[first, 2], "and", noun2))
}
#===========================================================================#
#===========================================================================#
#===========================================================================#
#===========================================================================#
#=========================#
#       NPC generator     #
npc = function(n = 1, stats = FALSE, ...) {
# Generating a name, race, and sex 'n' times and packaging it in a dataframe
npc.df = t(nameGen(...))
if(n > 1) {
for(i in 2:n) {
npc.df = rbind(npc.df, t(nameGen(...)))
}
# Checking for doubled up names; will generate a new one if there is
while(anyDuplicated(npc.df[, 2])) {
npc.df[anyDuplicated(npc.df[, 2]), ] = t(nameGen(...))
}
}
# Generating an age and alignment and sticking it on
npc.df = cbind(npc.df, ageGen(npc.df[, 1]), align(n))
# Labelling the columns
npc.colnames = c("Race", "Name", "Sex", "Age", "Alignment")
# Generating some random stats, if 'stats' = TRUE (Default = FALSE)
if(stats) {
# Getting the relevant columns: Str:Cha (AC and HP RNG'd)
statNames = c("Str", "Dex", "Con", "Int", "Wis", "Cha")
statsCols = grep(paste(statNames, collapse = "|"), names(workers))
# Randomly selecting 'n' rows
# Then looping through the block of stats and stripping out the modifier (so we can add our own)
rows = rng(n, 1, ncol(workers))
statsNoMods = apply(workers[rows, statsCols], 2, function(x) as.numeric(gsub(" \\([+-]?[0-9]\\)", "", x)))
# Creating our own modifier to stick on
mods = c(-5, rep(-4:5, each = 2))[statsNoMods]
mods[mods > 0] = paste0("+", mods[mods > 0])
# Randomly generating AC and HP
AC = rng(n, 10, 18)
HP = rng(n, 10, 20)
# Sticking our stats onto the main dataframe, and updating the column names
npc.df = cbind(npc.df, AC, matrix(paste0(statsNoMods, " (", mods, ")"),
ncol = 6,
nrow = n),
HP)
npc.colnames = c(npc.colnames, "AC", statNames, "HP")
}
# Packaging and printing
setNames(data.frame(npc.df, stringsAsFactors = FALSE), nm = npc.colnames)
}
npc()
npc()
max
max = 1
min = 0
rm(nameGen)
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
test = scr.sim(5, 150, test.data$traps, density = 5, acoustic = TRUE, lambda_c = 3)
## Some start values: D = 0.1, g0 = 0.5, sigma = 50.
par.start <- c(log(0.1), qlogis(0.5), log(50), 3)
Rcpp::sourceCpp('src/acoustic.cpp')
Rcpp::sourceCpp('src/acoustic.cpp')
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
test = scr.sim(5, 150, test.data$traps, density = 5, acoustic = TRUE, lambda_c = 3)
## Some start values: D = 0.1, g0 = 0.5, sigma = 50.
par.start <- c(log(0.1), qlogis(0.5), log(50), 3)
scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
t2 = scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
sum(t2)
Rcpp::sourceCpp('src/acoustic.cpp')
par.start <- c(log(0.1), qlogis(0.5), log(150), 3)
t2 = scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
head(t2)
length(t2)
Rcpp::sourceCpp('src/acoustic.cpp')
t2 = scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
length(t2)
head(t2)
length(unique(t2))
Rcpp::sourceCpp('src/acoustic.cpp')
t2 = scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
length(t2)
Rcpp::sourceCpp('src/acoustic.cpp')
Rcpp::sourceCpp('src/acoustic.cpp')
Rcpp::sourceCpp('src/acoustic.cpp')
t2 = scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
Rcpp::sourceCpp('src/acoustic.cpp')
t2 = scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
table(test[, ncol(test)]))
Rcpp::sourceCpp('src/scr-fit.cpp')
test
?scr.sim
test = scr.sim(5, 150, test.data$traps)
test = scr.sim(5, 150, test.data$traps, distr = "binom")
test = scr.sim(5, 150, test.data$traps, distr = "binary")
library(scr)
load("~/Business/University/Master's/Project/Likelihood/test-data.RData")
#Rcpp::sourceCpp('Business/University/Master\'s/Project/Package/scr/src/acoustic.cpp')
test = scr.sim(5, 150, test.data$traps, density = 5, acoustic = TRUE, lambda_c = 3)
## Some start values: D = 0.1, g0 = 0.5, sigma = 150.
par.start <- c(log(0.1), qlogis(0.5), log(150), 3)
scr_nll_acoustic(par.start, test[, -ncol(test)],
test.data$traps,
test.data$mask,
eucdist_nll(test.data$mask,
test.data$traps),
as.numeric(names(table(test[, ncol(test)]))),
table(test[, ncol(test)]))
table(test[, ncol(test)])
Rcpp::sourceCpp('src/acoustic.cpp')
library(scr)
library(roxygen2)
roxygenise()
